---
title: "Data Visualization"
date: "September 9-10, 2021"
output: 
  html_document:
    toc: TRUE
    toc_depth: 2
    toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Output devices

To export any kind of plot, you need some sort of "canvas" to draw on. In the RStudio GUI, as a default, plots will be printed in a new window, or if you are using R Markdown they will appear inline. Still, even in these cases you may want to use devices to write your plot to a file.

The kind of output that is produced is controlled by a ***device*** directive, which by default is set to `null device`. On a windows machine it is actually a device called `windows()`; on a Mac it is called `quartz()`.

+ You may choose the kind of output that is produced by redirecting the output to another type.
+ Different devices include: PDF, PostScript, bitmap, jpeg, png, and LaTeX.
+ These devices will not print to the GUI -- instead they will save a file in the working directory.

```{r}
#open a new window
#windows() #on a pc
quartz() #on a mac

#current device
dev.cur()

```

PDF output is really useful. Let us try to write a random plot to a pdf file.

```{r, collapse=TRUE}
#start pdf device
pdf("mycoolplot.pdf") # you can specify many other parameters here, e.g. size, dpi, etc

# make a random plot
plot(1)

#list of devices
dev.list()
dev.cur()
```

```{r, collapse=TRUE}
#select a device
dev.set(3)

#end a device or close a file
dev.off()
dev.cur()

dev.off()
dev.cur()
```

# Essentials of base R graphics

Here we introduce the basic elements of the [**graphics**](https://www.rdocumentation.org/packages/graphics/versions/3.6.2) package, which is part of the base R distribution. 

The **graphics** package provides ***functions*** for creating all kinds of plots. Many of these can be used to conveniently get a quick idea of what your data look like. They are simple yet powerful.

There are also many graphical ***parameters*** that can be set in order to control the appearance of points and lines, axis ticks, plot labels, text, and arrangement of plots when multiple plots are generated at the same time. Other packages will come with their own plotting functions, but generally they access the same range of parameters.

Learning to fine-tune the appearance of plots using the base graphics package can be very tedious and unrewarding. This is why we will transition to mainly using the **ggplot2** package to take our graphics to the next level. Nevertheless, we think it is important for you to know that these base functions exist and are available if you want to use them.

## The plot() function can automatically generate plots

The generic function for plotting R objects is aptly called `plot()`. The default output
of the function depends on the object it is passed.

`ldeaths` is an object of class `ts` (time series) that is provided in R.
This dataset provides the number of deaths in UK from 1974-1979 due to lung disease.
Since it is a numerical vector, the plot function plots a line.

```{r}
plot(ldeaths)
```

The built-in `iris` dataset contains measurements on sepals and petals of three different species of iris.
Its class is `data.frame`. In this case, `plot()` shows all comparisons between the 5 columns in the data frame.

```{r}
head(iris)
plot(iris)
```

## The plot() function can be also programmed to generate simple scatter plots

Rather than relying on the ability of `plot()` to automatically recognize the structure of your R object, you can use this function to create simple scatter plots by explicitly specifying `x` and `y` parameters.

```{r}
plot(x=iris$Sepal.Length,
     y=iris$Sepal.Width)
```

Let us color the points by species (`iris$Species`). Somewhat confusingly, the `plot()` help file (see `?plot`) does not describe any parameters to specify color. Instead, it says:
`... Arguments to be passed to methods, such as graphical parameters (see par).`
So, you should look up documentation for `par()` (`?par`), where you will find an extensive list of graphical parameters that you can pass to `plot()` and other similar functions. The parameter we need is `col`.

```{r}
plot(x=iris$Sepal.Length,
     y=iris$Sepal.Width,
     col='red') # pass a single value to color *all* points the same way
```
```{r}
species_colors = iris$Species # make a copy of the Species column
levels(species_colors) # examine the number of levels
levels(species_colors) = c("red","green","blue") # set color names as levels
species_colors = as.character(species_colors) # convert factor to character vector
species_colors # check

plot(x=iris$Sepal.Length,
     y=iris$Sepal.Width,
     col=species_colors) # pass a vector of colors to set the color of each point individually
```

You may also want to tweak some other things, e.g. axis labels. 

```{r}
plot(x=iris$Sepal.Length,
     y=iris$Sepal.Width,
     col=species_colors,
     xlab='Sepal length, mm',
     ylab='Sepal width, mm')
```

# Essentials of ggplot2

The following brief overview is adapted from an STHDA tutorial you can find [**here**](http://www.sthda.com/english/wiki/ggplot2-essentials) that covers all the basic types of plots you can make with ggplot. 

The concept behind ggplot2 divides plot into **three different fundamental** parts: 

**Plot = Data + Aesthetics + Geometry**

The principal elements of every plot can be defined as follows:

+ **Data** is a data frame (variables) to be plotted.
+ **Aesthetics**: the `aes()` function is used to indicate ***how*** to display the data: which categories or measurements to map to x and y coordinates; or color, size or shape of points, etc.
+ **Geometry** defines the ***type of graphics*** (histogram, box plot, line plot, density plot, dot plot, â€¦.)

There are **two major functions** in the ggplot2 package:

+ `qplot()` stands for quick plot, which can be used to produce easily simple plots.
+ `ggplot()` function is more flexible and robust than `qplot()` for building a plot piece by piece.

Plots are constructed by **layering** geometries, additional aesthetics, and themes on top of the primary aesthetic mapping.

The **basic syntax** is:

```{r, eval=FALSE, echo=TRUE}
ggplot(data = <data.frame>,
       mapping = aes(x = <column of data.frame>, y = <column of data.frame>)) +
  geom_<type of geometry>()
```

### Aesthetics

If your data is **tidy**, then the columns of your data frame will contain the variables that you want to display. Each of these can be mapped to different **aesthetics** of the graph (e.g. axis, colors, shapes, etc.). A few of the examples below are based on Chapter 3 from ***R for Data Science***.

There are **two ways** to specify aesthetics:

  * **Mapping**: This maps specific types of **data** to different visual elements
    + Mappings are included ***inside*** `aes()`.
    + In the base layer of the graph, the mapping will be applied to all geometries.
    + In another layer, the mapping will be applied only to a particular geometry.
  * **Setting**: Manually set an aesthetic **independently** of data
    + Settings are placed ***outside*** of an `aes()` directive.
    
Aesthetic elements include things such as:

+ x- and y- axes
+ Colors
+ The size of points (in mm)
+ The shape of points (a number; see below)
+ Transparency (range 0-1)

### Geometries

**Geometries** control the ***type of visual paradigm*** you want to use to display your data, for example:

+ geom_bar() - barchart
+ geom_histogram() - histogram
+ geom_dotplot() - dot plot, a.k.a. strip chart
+ geom_boxplot() - boxplot
+ geom_violin() - violin plot
+ geom_point() - scatterplot

Geom functions also allow you to add additional features to a graph, for example:

+ geom_jitter() - spread points out (e.g. on strip charts) to make the data more visible
+ geom_vline() - add a vertical line (can also add other kinds of lines)

Statistical features can also be layered onto graphs, e.g.:

+ geom_smooth() - a regression line (according to a global or local model)
+ stat_summary() - add some kind of statistical function to a graph
  + This can also be done by adding `stat = "something"` inside another geometry (some examples below)

### Themes

[**Themes**](https://ggplot2.tidyverse.org/reference/theme.html) are used to customize the non-data components of your graphs, such as titles, labels, fonts, background, gridlines, and legends. The default appearance of ggplot graphs produces graphs with a gray background and white gridlines. This can be changed to almost any look and feel by customizing their themes, which can also be used to give plots a consistent look for presentation.

In addition to setting `theme()` components manually, the [**ggthemes*](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) package also provides a variety of defined themes that replicate the look and feel for different visual paradigms and applications.

## qplot() can automatically generate plots

Let us recreate the Sepal.Length vs Sepal.Width scatterplot using `qplot()`.

```{r}
library(ggplot2)
head(iris)

# quick plot with defaults
qplot(x=Sepal.Length,
      y=Sepal.Width,
      data=iris,
      xlab='Sepal length, mm',
      ylab='Sepal width, mm',
      geom=c("point")) # set geometry - this is the biggest difference from base R
```

## ggplot() is a function to build plots piece-by-piece

Let us recreate the Sepal.Length vs Sepal.Width scatterplot using `ggplot()`.

```{r}
ggplot(data=iris, 
       mapping=aes(x=Sepal.Length,   # set aesthetics
                   y=Sepal.Width)) +
  geom_point() +                     # set geometry
  theme_grey() +                     # set theme (although this theme is default)
  xlab('Sepal length, mm') +
  ylab('Sepal width, mm')
```

Again, you can set a color for all points or each point independently depending on which species it belongs to.

```{r}
# pass a single value to the parameter color inside the geometry function to color *all* points the same way
ggplot(data=iris,
       mapping=aes(x=Sepal.Length,
                   y=Sepal.Width)) +
  geom_point(color="red") + # here
  xlab('Sepal length, mm') +
  ylab('Sepal width, mm')

# pass the name of the data.frame column by which to color points to the parameter color inside the aesthetics
ggplot(data=iris, 
       mapping=aes(x=Sepal.Length,
                   y=Sepal.Width,
                   color=Species)) + # here
  geom_point() +
  xlab('Sepal length, mm') +
  ylab('Sepal width, mm')

ggplot(data=iris, 
       mapping=aes(x=Sepal.Length,
                   y=Sepal.Width,
                   color=Species)) +
  geom_point(mapping=aes(color=Species)) + # you can also create an aesthetics mapping inside geometries!
  xlab('Sepal length, mm') +
  ylab('Sepal width, mm')
```

# Histograms

Histograms are good for showing the distribution of a **single quantitative variable**. Two or more distributions can be shown together on one histogram, though showing more than two or three gets really confusion. 

## hist() in base R

Base R has a special function called hist().

```{r}
hist(iris$Sepal.Length)
```

Keep in mind that `iris` contains data for three species, so the histogram above makes little biological sense because it is a mixture of measurements of three different species! There is no way to separate them inside `hist()`, so you may split the data.frame manually.

```{r}
virnica_rows = which(iris$Species=='virginica')
iris_virginica = iris[virnica_rows,]

hist(iris_virginica$Sepal.Length)
```

## qplot() and geom_histogram() in ggplot2

`qplot()` provides an easy way to display the data for the three species overlayed.

```{r}
qplot(x=Sepal.Length,
      data=iris,
      fill=Species,
      color=Species,
      alpha=0.5) # make the bars semi-transparent
```

The same with `ggplot()`:

```{r}
ggplot(data=iris,
       mapping=aes(x=Sepal.Length,
                   fill=Species,
                   color=Species))  +
  geom_histogram(alpha=0.5)
```

