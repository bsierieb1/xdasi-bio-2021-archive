---
title: "RDataStructures"
author: "Manpreet S. Katari"
date: "September 4, 2017"
output:  
  md_document:
    toc: true
    toc_depth: 2
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#R data types

R can store several different **types** of data:

- Numeric : numbers
- Complex : complex numbers (*i* = square root of -1)
- Logical : True/False
- Character: Alphanumeric values
- Raw     : Bytes (for example images)

These data types can be stored in different structures.

#R Data Structures

There are 5 basic types (classes) of data structures in R that we will come across most often:

- Vectors
- Factors
- Arrays ( and Matrices )
- Data Frames
- Lists

##The class of an object
The class of a vector is the same as a mode. So if you have a vector of numeric values, the class of the object is ``numeric``.

These classes help R act like an object-oriented language. For example the plot function for an object of class matrix is different then plot for numeric vector.

#Vectors

- This is the most basic data structure.
- It is a sequence of data that can be numbers, characters and also logical.
- A scalar is a vector of length 1.
- Vector of more than one element can be created using ``c()`` function.
- Elements of a vector must be same type and mode.
- Characters must be enclosed in either single or double quotes
- Missing data can be represented as NA

##Character Vectors
There are certain characters that have special meaning in R. To tell R not to use them as special meaning you have to use ``escape characters``. In R this is ``\``.

```{r, eval=F}
Escape characters \
\\  to use \ in string
\" to use " in string
\n new line character
\t tab character
\b backspace character
```

##Logical Vectors

A vector with three possible values:

- TRUE
- FALSE
- NA (Not available)

The can be generated by using operators that compare values.

###List of Logical operators

- <, <=, >, >=,
- == for exact equality
- != for inequality
- & (and)
- | (or)

Here are some examples:

```{r}
v <- c(4,2,3,8,2,2,5)
v

is(v) # the is functions gives you more information about type of data and data structure.

v <- c("a","b","c","d","e")
v

is(v)

v <- c(4,2,3,8,2,2,NA,5)
v


#changing values in a vector
v[4]
v[4] = 10

v < 4

v[1:3]
v[-c(1,5,8)]

# equivalent expressions
temp = v < 4
v[temp]

# same as below
v[v<4]


```

##Factors
Factors are a way defining groupings in your data. For example they are used to define control and treatment  samples. It is easy to convert a character vector into a factor by simply providing group names in the same order as the samples.

Factors are very helpful when you want to perform an operation to values within the groups. The example below demonstrates how you can calculate the ``mean`` of the values in each group. We will cover ``tapply`` later in the lecture.

```{r}

expgroup = c("groupA",
             "groupB",
             "groupA",
             "groupC",
             "groupC",
             "groupB",
             "groupA",
             "groupA")

expgroup<-factor(expgroup)

expgroup

levels(expgroup)

table(expgroup)

expvalues = c(2,5,7,3,8,0,9,0)

tapply(expvalues, expgroup, mean)

```

#R objects: Arrays and Matrices
An array is a multiply subscripted collection of data entries. Matrix is an example of a two-dimensional array. An easy way to create a matrix is to use the ``matrix()`` function or the ``array()`` function. The first argument for both functions is a data vector. Matrix then requires ``nrow`` and ``ncol`` arguments where as array requires a vector defining the dim property of the array. The ``dim()`` function can also be used to convert a vector to a matrix.

```{r}
#simple way
mat<-matrix(c(4,12,1,5,21,7,10,7,2,19,24,3),
            nrow=4,
            ncol=3)
mat

class(mat)

# retrieve specific values [row, column]
mat[2,3]

# if you are data is more than two dimensions, then this is
# better way.

mat<-array(c(4,12,1,5,21,7,10,7,2,19,24,3), dim=c(4,3))

mat

# if you want to convert a vector to a matrix
x=c(4,12,1,5,21,7,10,7,2,19,24,3)

dim(x)=c(4,3)

x
```


##Different ways to index

```{r}
#A vector of positive integral quantities.
x[1:10]

#specific rows, and all columns
mat[c(1,3,4),]

#A logical vector
mat[c(TRUE,TRUE,FALSE),]
v[v<5]

#Vector of character strings
fruit <- c(5, 10, 1, 20)
names(fruit) <- c("orange", "banana", "apple", "peach")
lunch <- fruit[c("apple","orange")]
lunch
```


##R objects: Creating matrices using cbind() and rbind()
Arguments to cbind() must be either vectors of any length, or matrices with the same column size, that is the same number of rows. For vectors that are shorter than the matrix, the values are cyclically added to the matrix

The example below is taken from a famous iris dataset provided within R. You can learn more about this dataset by typing

``help("iris")``


```{r}
#create vectors of values
sepal.length<-c(5.1,4.9,7.0,6.4,6.3,5.8)
sepal.width<-c(3.5,3.0,3.2,3.2,3.3,2.7)

mat<-cbind(sepal.length, sepal.width)
mat
mat[3,]

#colnames of matrix
colnames(mat)
rownames(mat)
rownames(mat) = c("p1","p2","p3","p4","p5","p6")

mat["p4","sepal.length"] = 5

# get logical matrix
mat < 4

mat [ mat < 4]
```

#R objects: Data Frames
A drawback to matrices is that all the values have to be the same mode (either all numeric or all character). If you try to combine a combination of types, it will defualt to character because numbers can be treated as characters but the characters can not be treated as numbers.

A dataframe is composed of vectors of the same length but can be of different modes. This makes it perfect structure for mixed-type biomedical data. Specific columns can be accessed using the ``$`` or traditional ``[]`` way for matrix.

- Dataframe$column
- Dataframe[,1]

Row labels can be modified using the rownames() function and similarly column labels can be modified using colnames() function

```{r}

species<-c("setosa","setosa",
          "versicolor","versicolor",
          "virginica","virginica")

#create a dataframe using the data.frame command
iris.df<-data.frame(sepal.width, sepal.length, species)

#Use $ to specific a column
table(iris.df$species)

#Use same method as matrix
iris.df[,2]

#notice the class of the column is a factor.
#by default data.frame converts character vectors to factors
class(iris.df[,"species"])

#notice that a row from a dataframe is still a dataframe
# because it contains data of multiple types.
class(iris.df[2,])

#an excellent functions to get a quick summary
summary(iris.df)

#assigning row names to a data frame.
rownames(iris.df)<-c("p1","p2","p3","p4","p5","p6")

iris.df

```

#R objects: Lists
List is a collection of objects. It can contain vectors, matrices, and dataframes of different lengths. It's a great way to collate different information

To access elements of a list use double sqaure brackets ``[[]]`` or names (if they have one) followed by ``$``


```{r}

a_list<-list(sepal.width, sepal.length,
             c("setosa", "versicolor","virginica"))

a_list

a_list<-list(width=sepal.width,
             length=sepal.length,
             species=c("setosa", "versicolor","virginica"),
             numberOfFlowers=50
             )

a_list$width

mean(a_list$length)

```

#Some other useful commands

- The ``mode()`` and ``typeof()`` functions provide mode and type of the object.
- The ``attributes()`` function provides useful information such as dimensions and names.
- The ``as()`` function can be used to coerce one object type to another.
- ``sample()`` - Get a random sample of numbers
- ``order()`` – Returns a numeric vector of the element position in ascending order
- ``sort()`` – Returns the values in ascending order
- ``paste()`` – Create a character vector by concatenating two other vectors
- ``print()`` – Prints content of an object to screen
- ``range()`` – Returns minimum and maximum value of a vector
- ``t()`` – Transpose a matrix or dataframe



```{r}
# notice the difference betwee sort and order
# one returns the value, the other returns the position
sepal.width
sort(sepal.width)
order(sepal.width)           

#convert a vector to a matrix.
as.matrix(sepal.width)

#converts a vector to a data frame.
as.data.frame(sepal.width)

# repeat elements in a vector
rep(sepal.width, times=5)
rep(sepal.width, each=5)

#quick way to generate numbers
1:30 #(shortcut for writing c(1,2,3 …. 28,29,30))
2*1:15 #(shortcut for c(2,4,6, … 28, 30))

#seq(from, to, by, length)
seq(-5, 5, by=.2) -> s3
s3

s4 <- seq(length=51, from=-5, by=.2)
s4

```


#ImportExport

R can import many different types of data files
- Tab delimited text file in ASCII format (.txt)
- American Standard Code for Information Interchange
- Comma delimited (CSV)
- Microsoft Excel file (.xls)
- Commercial and open source software
- SPSS, Minitab, SAS, Stata, WEKA, Octave
- XML (Extensible Markup Language)
- Databases such as MS Access (.mdb), Relational databases (mysql), and SQLite3

Download these files for the following exercise: [example.txt](example.txt) [example.csv](example.csv)

```{r}
data = read.table("example.txt")
data

```

What's wrong with data?

```{r}
data = read.table("example.txt",
                  header=T,
                  row.names=1)
data
```

Much better.

We can also use the ``read.csv()`` to read in our csv files. The defaults are different for the different varieties of the command.


```{r}
data2 = read.csv("example.csv",row.names=1)
data2
```

To create a file we will use the ``write.table()`` command.

```{r}
write.table(data, "adatafile.txt",
            sep="\t")
```

Open your new file and check to see how it is formatted. The command below the column names are adjusted slightly better. Also note that since the files was created using an .xls extension, your operative system will assume you want to open it with Excel, which it can.

```{r}
write.table(data,
            "adatafile.xls",
            col.names=NA,
            sep="\t")
```

# Apply function family

The functions apply(), tapply() and lapply() allows you to perform a specified function across array objects.

-   apply() – first provide the array then whether to apply the function by row (1), column(2) or both (c(1,2), finally the function.
-   tapply() – similar to apply but pass a factor vector instead of row or column
-   lapply() – simply provide a list and the function to apply to each vector in the list. Result is a list.
-   sapply() – same as lapply() but returns result in original data structure



```{r}
sampleData<-matrix(sample(20:160, 20,
                          replace=T)/10,
                   ncol=4,
                   nrow=5)

sampleData.df<-as.data.frame(sampleData)
colnames(sampleData.df)<-c("ctr1l",
                           "ctrl2",
                           "trt1",
                           "trt2")

rownames(sampleData.df)<-c("gene1",
                            "gene2",
                            "gene3",
                            "gene4",
                            "gene5")

```

Your sampleData will be different because it is being generated randomly

```{r}
sampleData
```

We can calculate the average of each row by simply applying the mean function to every row.

```{r}
apply(sampleData, 1, mean)
```

We can also use the `tapply` function to apply a function based on their groupings.

```{r}
expgroups = factor(c("ctrl", "ctrl", "trt", "trt"))

tapply(as.numeric(sampleData.df[1,]), expgroups, mean)
```

If we treat the dataframe as a list we can use lapply

```{r}
lapply(sampleData.df, mean)
```

You can also apply a tapply function.

```{r}
apply(sampleData.df, 1, tapply, expgroups, mean)
```

Notice that here we needed to provide additional arguments to the tapply function. Since the first one is simply the data, which the ``apply()`` function is providing, we don't need to worry about it. The second argument for using tapply is the factor, we can simply add that to parameters and finally also the function ``mean()`` itself.

The results are actually returned column by column. In case there are too may columns, remember you can always transpose ``t()`` your dataset.

```{r}
t(apply(sampleData.df, 1, tapply, expgroups, mean))

```
