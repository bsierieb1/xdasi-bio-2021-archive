---
title: Data Structures
parent: R Tutorial
grand_parent: Learning R
nav_order: 5
has_children: false
---

# R Data Structures -- NEED TO REORG -- HERE INCLUDES DATA TYPES, VARIABLES, VECTORS, ARRAYS, ETC -- TOO MUCH HERE
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

- TOC
{:toc}

---

YouTube Video - <https://youtu.be/i7zYGLgO9Kk>

R can store several different **types** of data:

-   Numeric : numbers
-   Complex : complex numbers (*i* = square root of -1)
-   Logical : True/False
-   Character: Alphanumeric values
-   Raw : Bytes (for example images)

These data types can be stored in different structures.

R Data Structures
=================

There are 5 basic types (classes) of data structures in R that we will come across most often:

-   Vectors
-   Factors
-   Arrays ( and Matrices )
-   Data Frames
-   Lists

The class of an object
----------------------

The class of a vector is the same as a mode. So if you have a vector of numeric values, the class of the object is `numeric`.

These classes help R act like an object-oriented language. For example the plot function for an object of class matrix is different then plot for numeric vector.

Vectors
=======

-   This is the most basic data structure.
-   It is a sequence of data that can be numbers, characters and also logical.
-   A scalar is a vector of length 1.
-   Vector of more than one element can be created using `c()` function.
-   Elements of a vector must be same type and mode.
-   Characters must be enclosed in either single or double quotes
-   Missing data can be represented as NA

Character Vectors
-----------------

There are certain characters that have special meaning in R. To tell R not to use them as special meaning you have to use `escape characters`. In R this is `\`.

``` r
Escape characters \
\\  to use \ in string
\" to use " in string
\n new line character
\t tab character
\b backspace character
```

Logical Vectors
---------------

A vector with three possible values:

-   TRUE
-   FALSE
-   NA (Not available)

The can be generated by using operators that compare values.

### List of Logical operators

-   &lt;, &lt;=, &gt;, &gt;=,
-   == for exact equality
-   != for inequality
-   & (and)
-   (or)

Here are some examples:

``` r
v <- c(4,2,3,8,2,2,5)
v
```

    ## [1] 4 2 3 8 2 2 5

``` r
is(v) # the is functions gives you more information about type of data and data structure.
```

    ## [1] "numeric" "vector"

``` r
v <- c("a","b","c","d","e")
v
```

    ## [1] "a" "b" "c" "d" "e"

``` r
is(v)
```

    ## [1] "character"           "vector"              "data.frameRowLabels"
    ## [4] "SuperClassMethod"

``` r
v <- c(4,2,3,8,2,2,NA,5)
v
```

    ## [1]  4  2  3  8  2  2 NA  5

``` r
#changing values in a vector
v[4]
```

    ## [1] 8

``` r
v[4] = 10

v < 4
```

    ## [1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE    NA FALSE

``` r
v[1:3]
```

    ## [1] 4 2 3

``` r
v[-c(1,5,8)]
```

    ## [1]  2  3 10  2 NA

``` r
# equivalent expressions
temp = v < 4
v[temp]
```

    ## [1]  2  3  2  2 NA

``` r
# same as below
v[v<4]
```

    ## [1]  2  3  2  2 NA

Factors
-------

YouTube Video - <https://youtu.be/VOcHEJvkJLw>

Factors are a way defining groupings in your data. For example they are used to define control and treatment samples. It is easy to convert a character vector into a factor by simply providing group names in the same order as the samples.

Factors are very helpful when you want to perform an operation to values within the groups. The example below demonstrates how you can calculate the `mean` of the values in each group. We will cover `tapply` later in the lecture.

``` r
expgroup = c("groupA",
             "groupB",
             "groupA",
             "groupC",
             "groupC",
             "groupB",
             "groupA",
             "groupA")

expgroup<-factor(expgroup)

expgroup
```

    ## [1] groupA groupB groupA groupC groupC groupB groupA groupA
    ## Levels: groupA groupB groupC

``` r
levels(expgroup)
```

    ## [1] "groupA" "groupB" "groupC"

``` r
table(expgroup)
```

    ## expgroup
    ## groupA groupB groupC
    ##      4      2      2

``` r
expvalues = c(2,5,7,3,8,0,9,0)

tapply(expvalues, expgroup, mean)
```

    ## groupA groupB groupC
    ##    4.5    2.5    5.5

R objects: Arrays and Matrices
==============================

YouTube Video - <https://youtu.be/-QqjotZAhTk>

An array is a multiply subscripted collection of data entries. Matrix is an example of a two-dimensional array. An easy way to create a matrix is to use the `matrix()` function or the `array()` function. The first argument for both functions is a data vector. Matrix then requires `nrow` and `ncol` arguments where as array requires a vector defining the dim property of the array. The `dim()` function can also be used to convert a vector to a matrix.

``` r
#simple way
mat<-matrix(c(4,12,1,5,21,7,10,7,2,19,24,3),
            nrow=4,
            ncol=3)
mat
```

    ##      [,1] [,2] [,3]
    ## [1,]    4   21    2
    ## [2,]   12    7   19
    ## [3,]    1   10   24
    ## [4,]    5    7    3

``` r
class(mat)
```

    ## [1] "matrix"

``` r
# retrieve specific values [row, column]
mat[2,3]
```

    ## [1] 19

``` r
# if you are data is more than two dimensions, then this is
# better way.

mat<-array(c(4,12,1,5,21,7,10,7,2,19,24,3), dim=c(4,3))

mat
```

    ##      [,1] [,2] [,3]
    ## [1,]    4   21    2
    ## [2,]   12    7   19
    ## [3,]    1   10   24
    ## [4,]    5    7    3

``` r
# if you want to convert a vector to a matrix
x=c(4,12,1,5,21,7,10,7,2,19,24,3)

dim(x)=c(4,3)

x
```

    ##      [,1] [,2] [,3]
    ## [1,]    4   21    2
    ## [2,]   12    7   19
    ## [3,]    1   10   24
    ## [4,]    5    7    3

Different ways to index
-----------------------

``` r
#A vector of positive integral quantities.
x[1:10]
```

    ##  [1]  4 12  1  5 21  7 10  7  2 19

``` r
#specific rows, and all columns
mat[c(1,3,4),]
```

    ##      [,1] [,2] [,3]
    ## [1,]    4   21    2
    ## [2,]    1   10   24
    ## [3,]    5    7    3

``` r
#A logical vector
mat[c(TRUE,TRUE,FALSE),]
```

    ##      [,1] [,2] [,3]
    ## [1,]    4   21    2
    ## [2,]   12    7   19
    ## [3,]    5    7    3

``` r
v[v<5]
```

    ## [1]  4  2  3  2  2 NA

``` r
#Vector of character strings
fruit <- c(5, 10, 1, 20)
names(fruit) <- c("orange", "banana", "apple", "peach")
lunch <- fruit[c("apple","orange")]
lunch
```

    ##  apple orange
    ##      1      5

R objects: Creating matrices using cbind() and rbind()
------------------------------------------------------

Arguments to cbind() must be either vectors of any length, or matrices with the same column size, that is the same number of rows. For vectors that are shorter than the matrix, the values are cyclically added to the matrix

The example below is taken from a famous iris dataset provided within R. You can learn more about this dataset by typing

`help("iris")`

``` r
#create vectors of values
sepal.length<-c(5.1,4.9,7.0,6.4,6.3,5.8)
sepal.width<-c(3.5,3.0,3.2,3.2,3.3,2.7)

mat<-cbind(sepal.length, sepal.width)
mat
```

    ##      sepal.length sepal.width
    ## [1,]          5.1         3.5
    ## [2,]          4.9         3.0
    ## [3,]          7.0         3.2
    ## [4,]          6.4         3.2
    ## [5,]          6.3         3.3
    ## [6,]          5.8         2.7

``` r
mat[3,]
```

    ## sepal.length  sepal.width
    ##          7.0          3.2

``` r
#colnames of matrix
colnames(mat)
```

    ## [1] "sepal.length" "sepal.width"

``` r
rownames(mat)
```

    ## NULL

``` r
rownames(mat) = c("p1","p2","p3","p4","p5","p6")

mat["p4","sepal.length"] = 5

# get logical matrix
mat < 4
```

    ##    sepal.length sepal.width
    ## p1        FALSE        TRUE
    ## p2        FALSE        TRUE
    ## p3        FALSE        TRUE
    ## p4        FALSE        TRUE
    ## p5        FALSE        TRUE
    ## p6        FALSE        TRUE

``` r
mat [ mat < 4]
```

    ## [1] 3.5 3.0 3.2 3.2 3.3 2.7

R objects: Data Frames
======================

YouTube Video - <https://youtu.be/W0Pp2Thp6to>

A drawback to matrices is that all the values have to be the same mode (either all numeric or all character). If you try to combine a combination of types, it will defualt to character because numbers can be treated as characters but the characters can not be treated as numbers.

A dataframe is composed of vectors of the same length but can be of different modes. This makes it perfect structure for mixed-type biomedical data. Specific columns can be accessed using the `$` or traditional `[]` way for matrix.

-   Dataframe$column
-   Dataframe\[,1\]

Row labels can be modified using the rownames() function and similarly column labels can be modified using colnames() function

``` r
species<-c("setosa","setosa",
          "versicolor","versicolor",
          "virginica","virginica")

#create a dataframe using the data.frame command
iris.df<-data.frame(sepal.width, sepal.length, species)

#Use $ to specific a column
table(iris.df$species)
```

    ##
    ##     setosa versicolor  virginica
    ##          2          2          2

``` r
#Use same method as matrix
iris.df[,2]
```

    ## [1] 5.1 4.9 7.0 6.4 6.3 5.8

``` r
#notice the class of the column is a factor.
#by default data.frame converts character vectors to factors
class(iris.df[,"species"])
```

    ## [1] "factor"

``` r
#notice that a row from a dataframe is still a dataframe
# because it contains data of multiple types.
class(iris.df[2,])
```

    ## [1] "data.frame"

``` r
#an excellent functions to get a quick summary
summary(iris.df)
```

    ##   sepal.width     sepal.length         species
    ##  Min.   :2.700   Min.   :4.900   setosa    :2  
    ##  1st Qu.:3.050   1st Qu.:5.275   versicolor:2  
    ##  Median :3.200   Median :6.050   virginica :2  
    ##  Mean   :3.150   Mean   :5.917                 
    ##  3rd Qu.:3.275   3rd Qu.:6.375                 
    ##  Max.   :3.500   Max.   :7.000

``` r
#assigning row names to a data frame.
rownames(iris.df)<-c("p1","p2","p3","p4","p5","p6")

iris.df
```

    ##    sepal.width sepal.length    species
    ## p1         3.5          5.1     setosa
    ## p2         3.0          4.9     setosa
    ## p3         3.2          7.0 versicolor
    ## p4         3.2          6.4 versicolor
    ## p5         3.3          6.3  virginica
    ## p6         2.7          5.8  virginica

R objects: Lists
================

List is a collection of objects. It can contain vectors, matrices, and dataframes of different lengths. It's a great way to collate different information

To access elements of a list use double sqaure brackets `[[]]` or names (if they have one) followed by `$`

``` r
a_list<-list(sepal.width, sepal.length,
             c("setosa", "versicolor","virginica"))

a_list
```

    ## [[1]]
    ## [1] 3.5 3.0 3.2 3.2 3.3 2.7
    ##
    ## [[2]]
    ## [1] 5.1 4.9 7.0 6.4 6.3 5.8
    ##
    ## [[3]]
    ## [1] "setosa"     "versicolor" "virginica"

``` r
a_list<-list(width=sepal.width,
             length=sepal.length,
             species=c("setosa", "versicolor","virginica"),
             numberOfFlowers=50
             )

a_list$width
```

    ## [1] 3.5 3.0 3.2 3.2 3.3 2.7

``` r
mean(a_list$length)
```

    ## [1] 5.916667

Some other useful commands
==========================

YouTube Video - <https://youtu.be/v_184INizAs>

-   The `mode()` and `typeof()` functions provide mode and type of the object.
-   The `attributes()` function provides useful information such as dimensions and names.
-   The `as()` function can be used to coerce one object type to another.
-   `sample()` - Get a random sample of numbers
-   `order()` – Returns a numeric vector of the element position in ascending order
-   `sort()` – Returns the values in ascending order
-   `paste()` – Create a character vector by concatenating two other vectors
-   `print()` – Prints content of an object to screen
-   `range()` – Returns minimum and maximum value of a vector
-   `t()` – Transpose a matrix or dataframe

``` r
# notice the difference betwee sort and order
# one returns the value, the other returns the position
sepal.width
```

    ## [1] 3.5 3.0 3.2 3.2 3.3 2.7

``` r
sort(sepal.width)
```

    ## [1] 2.7 3.0 3.2 3.2 3.3 3.5

``` r
order(sepal.width)           
```

    ## [1] 6 2 3 4 5 1

``` r
#convert a vector to a matrix.
as.matrix(sepal.width)
```

    ##      [,1]
    ## [1,]  3.5
    ## [2,]  3.0
    ## [3,]  3.2
    ## [4,]  3.2
    ## [5,]  3.3
    ## [6,]  2.7

``` r
#converts a vector to a data frame.
as.data.frame(sepal.width)
```

    ##   sepal.width
    ## 1         3.5
    ## 2         3.0
    ## 3         3.2
    ## 4         3.2
    ## 5         3.3
    ## 6         2.7

``` r
# repeat elements in a vector
rep(sepal.width, times=5)
```

    ##  [1] 3.5 3.0 3.2 3.2 3.3 2.7 3.5 3.0 3.2 3.2 3.3 2.7 3.5 3.0 3.2 3.2 3.3
    ## [18] 2.7 3.5 3.0 3.2 3.2 3.3 2.7 3.5 3.0 3.2 3.2 3.3 2.7

``` r
rep(sepal.width, each=5)
```

    ##  [1] 3.5 3.5 3.5 3.5 3.5 3.0 3.0 3.0 3.0 3.0 3.2 3.2 3.2 3.2 3.2 3.2 3.2
    ## [18] 3.2 3.2 3.2 3.3 3.3 3.3 3.3 3.3 2.7 2.7 2.7 2.7 2.7

``` r
#quick way to generate numbers
1:30 #(shortcut for writing c(1,2,3 …. 28,29,30))
```

    ##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
    ## [24] 24 25 26 27 28 29 30

``` r
2*1:15 #(shortcut for c(2,4,6, … 28, 30))
```

    ##  [1]  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30

``` r
#seq(from, to, by, length)
seq(-5, 5, by=.2) -> s3
s3
```

    ##  [1] -5.0 -4.8 -4.6 -4.4 -4.2 -4.0 -3.8 -3.6 -3.4 -3.2 -3.0 -2.8 -2.6 -2.4
    ## [15] -2.2 -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 -0.6 -0.4 -0.2  0.0  0.2  0.4
    ## [29]  0.6  0.8  1.0  1.2  1.4  1.6  1.8  2.0  2.2  2.4  2.6  2.8  3.0  3.2
    ## [43]  3.4  3.6  3.8  4.0  4.2  4.4  4.6  4.8  5.0

``` r
s4 <- seq(length=51, from=-5, by=.2)
s4
```

    ##  [1] -5.0 -4.8 -4.6 -4.4 -4.2 -4.0 -3.8 -3.6 -3.4 -3.2 -3.0 -2.8 -2.6 -2.4
    ## [15] -2.2 -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 -0.6 -0.4 -0.2  0.0  0.2  0.4
    ## [29]  0.6  0.8  1.0  1.2  1.4  1.6  1.8  2.0  2.2  2.4  2.6  2.8  3.0  3.2
    ## [43]  3.4  3.6  3.8  4.0  4.2  4.4  4.6  4.8  5.0

ImportExport
============

YouTube Video - <https://youtu.be/gN-WL5rYb7s>

R can import many different types of data files - Tab delimited text file in ASCII format (.txt) - American Standard Code for Information Interchange - Comma delimited (CSV) - Microsoft Excel file (.xls) - Commercial and open source software - SPSS, Minitab, SAS, Stata, WEKA, Octave - XML (Extensible Markup Language) - Databases such as MS Access (.mdb), Relational databases (mysql), and SQLite3

Download these files for the following exercise: [example.txt](example.txt) [example.csv](example.csv)

``` r
data = read.table("example.txt")
data
```

    ##           V1    V2        V3       V4     V5          V6   V7  V8 V9
    ## 1  patientid grade nodesexam nodespos extent nodalstatus size pgr er
    ## 2   pid00001     3        32        3     10           6   60   2  2
    ## 3   pid00002     2        13        1     10           6   15   1  1
    ## 4   pid00003     3         8        0     10           0    8   1  1
    ## 5   pid00004     3        20        0     10           0   10   2  2
    ## 6   pid00005     2        16        8     10           6   15   2  1
    ## 7   pid00006     3        19        0     10           0   48   1  1
    ## 8   pid00007     3         3        0     10           0   32   2  2
    ## 9   pid00008     2        13        0     10           0   15   1  1
    ## 10  pid00009     3        21        0     10           0   22   1  1
    ## 11  pid00010     2        15        0     10           0    6   2  1

What's wrong with data?

``` r
data = read.table("example.txt",
                  header=T,
                  row.names=1)
data
```

    ##          grade nodesexam nodespos extent nodalstatus size pgr er
    ## pid00001     3        32        3     10           6   60   2  2
    ## pid00002     2        13        1     10           6   15   1  1
    ## pid00003     3         8        0     10           0    8   1  1
    ## pid00004     3        20        0     10           0   10   2  2
    ## pid00005     2        16        8     10           6   15   2  1
    ## pid00006     3        19        0     10           0   48   1  1
    ## pid00007     3         3        0     10           0   32   2  2
    ## pid00008     2        13        0     10           0   15   1  1
    ## pid00009     3        21        0     10           0   22   1  1
    ## pid00010     2        15        0     10           0    6   2  1

Much better.

We can also use the `read.csv()` to read in our csv files. The defaults are different for the different varieties of the command.

``` r
data2 = read.csv("example.csv",row.names=1)
data2
```

    ##          grade nodesexam nodespos extent nodalstatus size pgr er
    ## pid00001     3        32        3     10           6   60   2  2
    ## pid00002     2        13        1     10           6   15   1  1
    ## pid00003     3         8        0     10           0    8   1  1
    ## pid00004     3        20        0     10           0   10   2  2
    ## pid00005     2        16        8     10           6   15   2  1
    ## pid00006     3        19        0     10           0   48   1  1
    ## pid00007     3         3        0     10           0   32   2  2
    ## pid00008     2        13        0     10           0   15   1  1
    ## pid00009     3        21        0     10           0   22   1  1
    ## pid00010     2        15        0     10           0    6   2  1

To create a file we will use the `write.table()` command.

``` r
write.table(data, "adatafile.txt",
            sep="\t")
```

Open your new file and check to see how it is formatted. The command below the column names are adjusted slightly better. Also note that since the files was created using an .xls extension, your operative system will assume you want to open it with Excel, which it can.

``` r
write.table(data,
            "adatafile.xls",
            col.names=NA,
            sep="\t")
```

Apply function family
=====================

YouTube Video - <https://youtu.be/3F-1P2rDQ5c>

The functions apply(), tapply() and lapply() allows you to perform a specified function across array objects.

-   apply() – first provide the array then whether to apply the function by row (1), column(2) or both (c(1,2), finally the function.
-   tapply() – similar to apply but pass a factor vector instead of row or column
-   lapply() – simply provide a list and the function to apply to each vector in the list. Result is a list.
-   sapply() – same as lapply() but returns result in original data structure

``` r
sampleData<-matrix(sample(20:160, 20,
                          replace=T)/10,
                   ncol=4,
                   nrow=5)

sampleData.df<-as.data.frame(sampleData)
colnames(sampleData.df)<-c("ctr1l",
                           "ctrl2",
                           "trt1",
                           "trt2")

rownames(sampleData.df)<-c("gene1",
                            "gene2",
                            "gene3",
                            "gene4",
                            "gene5")
```

Your sampleData will be different because it is being generated randomly

``` r
sampleData
```

    ##      [,1] [,2] [,3] [,4]
    ## [1,] 14.0 11.4  8.1  7.1
    ## [2,]  9.2 15.7  9.8 12.3
    ## [3,]  6.1  6.0 12.3 13.5
    ## [4,]  3.1 13.3 12.8 12.8
    ## [5,] 12.8 13.2 11.1  7.8

We can calculate the average of each row by simply applying the mean function to every row.

``` r
apply(sampleData, 1, mean)
```

    ## [1] 10.150 11.750  9.475 10.500 11.225

We can also use the `tapply` function to apply a function based on their groupings.

``` r
expgroups = factor(c("ctrl", "ctrl", "trt", "trt"))

tapply(as.numeric(sampleData.df[1,]), expgroups, mean)
```

    ## ctrl  trt
    ## 12.7  7.6

If we treat the dataframe as a list we can use lapply

``` r
lapply(sampleData.df, mean)
```

    ## $ctr1l
    ## [1] 9.04
    ##
    ## $ctrl2
    ## [1] 11.92
    ##
    ## $trt1
    ## [1] 10.82
    ##
    ## $trt2
    ## [1] 10.7

You can also apply a tapply function.

``` r
apply(sampleData.df, 1, tapply, expgroups, mean)
```

    ##      gene1 gene2 gene3 gene4 gene5
    ## ctrl  12.7 12.45  6.05   8.2 13.00
    ## trt    7.6 11.05 12.90  12.8  9.45

Notice that here we needed to provide additional arguments to the tapply function. Since the first one is simply the data, which the `apply()` function is providing, we don't need to worry about it. The second argument for using tapply is the factor, we can simply add that to parameters and finally also the function `mean()` itself.

The results are actually returned column by column. In case there are too may columns, remember you can always transpose `t()` your dataset.

``` r
t(apply(sampleData.df, 1, tapply, expgroups, mean))
```

    ##        ctrl   trt
    ## gene1 12.70  7.60
    ## gene2 12.45 11.05
    ## gene3  6.05 12.90
    ## gene4  8.20 12.80
    ## gene5 13.00  9.45
